static int
vmw_gb_surface_define_internal(struct drm_device *dev,
			       struct drm_vmw_gb_surface_create_ext_req *req,
			       struct drm_vmw_gb_surface_create_rep *rep,
			       struct drm_file *file_priv)
{
	struct ttm_object_file *tfile = vmw_fpriv(file_priv)->tfile;
	struct vmw_private *dev_priv = vmw_priv(dev);
	struct vmw_user_surface *user_srf;
	struct vmw_surface_metadata metadata = {0};
	struct vmw_surface *srf;
	struct vmw_resource *res;
	struct vmw_resource *tmp;
	int ret = 0;
	uint32_t backup_handle = 0;
	SVGA3dSurfaceAllFlags svga3d_flags_64 =
		SVGA3D_FLAGS_64(req->svga3d_flags_upper_32_bits,
				req->base.svga3d_flags);

	/* array_size must be null for non-GL3 host. */
	if (req->base.array_size > 0 && !has_sm4_context(dev_priv)) {
		VMW_DEBUG_USER("SM4 surface not supported.\n");
		return -EINVAL;
	}

	if (!has_sm4_1_context(dev_priv)) {
		if (req->svga3d_flags_upper_32_bits != 0)
			ret = -EINVAL;

		if (req->base.multisample_count != 0)
			ret = -EINVAL;

		if (req->multisample_pattern != SVGA3D_MS_PATTERN_NONE)
			ret = -EINVAL;

		if (req->quality_level != SVGA3D_MS_QUALITY_NONE)
			ret = -EINVAL;

		if (ret) {
			VMW_DEBUG_USER("SM4.1 surface not supported.\n");
			return ret;
		}
	}

	if (req->buffer_byte_stride > 0 && !has_sm5_context(dev_priv)) {
		VMW_DEBUG_USER("SM5 surface not supported.\n");
		return -EINVAL;
	}

	if ((svga3d_flags_64 & SVGA3D_SURFACE_MULTISAMPLE) &&
	    req->base.multisample_count == 0) {
		VMW_DEBUG_USER("Invalid sample count.\n");
		return -EINVAL;
	}

	if (req->base.mip_levels > DRM_VMW_MAX_MIP_LEVELS) {
		VMW_DEBUG_USER("Invalid mip level.\n");
		return -EINVAL;
	}

	metadata.flags = svga3d_flags_64;
	metadata.format = req->base.format;
	metadata.mip_levels[0] = req->base.mip_levels;
	metadata.multisample_count = req->base.multisample_count;
	metadata.multisample_pattern = req->multisample_pattern;
	metadata.quality_level = req->quality_level;
	metadata.array_size = req->base.array_size;
	metadata.buffer_byte_stride = req->buffer_byte_stride;
	metadata.num_sizes = 1;
	metadata.base_size = req->base.base_size;
	metadata.scanout = req->base.drm_surface_flags &
		drm_vmw_surface_flag_scanout;

	/* Define a surface based on the parameters. */
	ret = vmw_gb_surface_define(dev_priv, &metadata, &srf);
	if (ret != 0) {
		VMW_DEBUG_USER("Failed to define surface.\n");
		return ret;
	}

	user_srf = container_of(srf, struct vmw_user_surface, srf);
	if (drm_is_primary_client(file_priv))
		user_srf->master = drm_file_get_master(file_priv);

	res = &user_srf->srf.res;

	if (req->base.buffer_handle != SVGA3D_INVALID_ID) {
		ret = vmw_user_bo_lookup(file_priv, req->base.buffer_handle,
					 &res->guest_memory_bo);
		if (ret == 0) {
			if (res->guest_memory_bo->tbo.base.size < res->guest_memory_size) {
				VMW_DEBUG_USER("Surface backup buffer too small.\n");
				vmw_bo_unreference(&res->guest_memory_bo);
				ret = -EINVAL;
				goto out_unlock;
			} else {
				backup_handle = req->base.buffer_handle;
			}
		}
	} else if (req->base.drm_surface_flags &
		   (drm_vmw_surface_flag_create_buffer |
		    drm_vmw_surface_flag_coherent)) {
		ret = vmw_gem_object_create_with_handle(dev_priv, file_priv,
							res->guest_memory_size,
							&backup_handle,
							&res->guest_memory_bo);
		if (ret == 0)
			vmw_bo_reference(res->guest_memory_bo);
	}

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	if (req->base.drm_surface_flags & drm_vmw_surface_flag_coherent) {
		struct vmw_bo *backup = res->guest_memory_bo;

		ttm_bo_reserve(&backup->tbo, false, false, NULL);
		if (!res->func->dirty_alloc)
			ret = -EINVAL;
		if (!ret)
			ret = vmw_bo_dirty_add(backup);
		if (!ret) {
			res->coherent = true;
			ret = res->func->dirty_alloc(res);
		}
		ttm_bo_unreserve(&backup->tbo);
		if (ret) {
			vmw_resource_unreference(&res);
			goto out_unlock;
		}

	}

	tmp = vmw_resource_reference(res);
	ret = ttm_prime_object_init(tfile, res->guest_memory_size, &user_srf->prime,
				    req->base.drm_surface_flags &
				    drm_vmw_surface_flag_shareable,
				    VMW_RES_SURFACE,
				    &vmw_user_surface_base_release);

	if (unlikely(ret != 0)) {
		vmw_resource_unreference(&tmp);
		vmw_resource_unreference(&res);
		goto out_unlock;
	}

	rep->handle      = user_srf->prime.base.handle;
	rep->backup_size = res->guest_memory_size;
	if (res->guest_memory_bo) {
		rep->buffer_map_handle =
			drm_vma_node_offset_addr(&res->guest_memory_bo->tbo.base.vma_node);
		rep->buffer_size = res->guest_memory_bo->tbo.base.size;
		rep->buffer_handle = backup_handle;
	} else {
		rep->buffer_map_handle = 0;
		rep->buffer_size = 0;
		rep->buffer_handle = SVGA3D_INVALID_ID;
	}
	vmw_resource_unreference(&res);

out_unlock:
	return ret;
}