void kmsg_dump(enum kmsg_dump_reason reason)
{
	u64 idx;
	struct kmsg_dumper *dumper;
	const char *s1, *s2;
	unsigned long l1, l2;
	unsigned long flags;

	if ((reason > KMSG_DUMP_OOPS) && !always_kmsg_dump)
		return;

	/* Theoretically, the log could move on after we do this, but
	   there's not a lot we can do about that. The new messages
	   will overwrite the start of what we dump. */

	raw_spin_lock_irqsave(&logbuf_lock, flags);
	if (syslog_seq < log_first_seq)
		idx = syslog_idx;
	else
		idx = log_first_idx;

	if (idx > log_next_idx) {
		s1 = log_buf;
		l1 = log_next_idx;

		s2 = log_buf + idx;
		l2 = log_buf_len - idx;
	} else {
		s1 = "";
		l1 = 0;

		s2 = log_buf + idx;
		l2 = log_next_idx - idx;
	}
	raw_spin_unlock_irqrestore(&logbuf_lock, flags);

	rcu_read_lock();
	list_for_each_entry_rcu(dumper, &dump_list, list)
		dumper->dump(dumper, reason, s1, l1, s2, l2);
	rcu_read_unlock();
}