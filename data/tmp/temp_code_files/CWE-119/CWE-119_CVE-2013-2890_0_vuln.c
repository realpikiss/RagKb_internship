static int buzz_init(struct hid_device *hdev)
{
	struct sony_sc *drv_data;
	struct buzz_extra *buzz;
	int n, ret = 0;
	struct led_classdev *led;
	size_t name_sz;
	char *name;

	drv_data = hid_get_drvdata(hdev);
	BUG_ON(!(drv_data->quirks & BUZZ_CONTROLLER));

	buzz = kzalloc(sizeof(*buzz), GFP_KERNEL);
	if (!buzz) {
		hid_err(hdev, "Insufficient memory, cannot allocate driver data\n");
		return -ENOMEM;
	}
	drv_data->extra = buzz;

	/* Clear LEDs as we have no way of reading their initial state. This is
	 * only relevant if the driver is loaded after somebody actively set the
	 * LEDs to on */
	buzz_set_leds(hdev, 0x00);

	name_sz = strlen(dev_name(&hdev->dev)) + strlen("::buzz#") + 1;

	for (n = 0; n < 4; n++) {
		led = kzalloc(sizeof(struct led_classdev) + name_sz, GFP_KERNEL);
		if (!led) {
			hid_err(hdev, "Couldn't allocate memory for LED %d\n", n);
			goto error_leds;
		}

		name = (void *)(&led[1]);
		snprintf(name, name_sz, "%s::buzz%d", dev_name(&hdev->dev), n + 1);
		led->name = name;
		led->brightness = 0;
		led->max_brightness = 1;
		led->brightness_get = buzz_led_get_brightness;
		led->brightness_set = buzz_led_set_brightness;

		if (led_classdev_register(&hdev->dev, led)) {
			hid_err(hdev, "Failed to register LED %d\n", n);
			kfree(led);
			goto error_leds;
		}

		buzz->leds[n] = led;
	}

	return ret;

error_leds:
	for (n = 0; n < 4; n++) {
		led = buzz->leds[n];
		buzz->leds[n] = NULL;
		if (!led)
			continue;
		led_classdev_unregister(led);
		kfree(led);
	}

	kfree(drv_data->extra);
	drv_data->extra = NULL;
	return ret;
}