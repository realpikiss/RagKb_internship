static ssize_t ll_direct_IO_26(int rw, struct kiocb *iocb,
			       struct iov_iter *iter, loff_t file_offset)
{
	struct lu_env *env;
	struct cl_io *io;
	struct file *file = iocb->ki_filp;
	struct inode *inode = file->f_mapping->host;
	struct ccc_object *obj = cl_inode2ccc(inode);
	long count = iov_iter_count(iter);
	long tot_bytes = 0, result = 0;
	struct ll_inode_info *lli = ll_i2info(inode);
	unsigned long seg = 0;
	long size = MAX_DIO_SIZE;
	int refcheck;

	if (!lli->lli_has_smd)
		return -EBADF;

	/* FIXME: io smaller than PAGE_SIZE is broken on ia64 ??? */
	if ((file_offset & ~CFS_PAGE_MASK) || (count & ~CFS_PAGE_MASK))
		return -EINVAL;

	CDEBUG(D_VFSTRACE, "VFS Op:inode=%lu/%u(%p), size=%lu (max %lu), "
	       "offset=%lld=%llx, pages %lu (max %lu)\n",
	       inode->i_ino, inode->i_generation, inode, count, MAX_DIO_SIZE,
	       file_offset, file_offset, count >> PAGE_CACHE_SHIFT,
	       MAX_DIO_SIZE >> PAGE_CACHE_SHIFT);

	/* Check that all user buffers are aligned as well */
	if (iov_iter_alignment(iter) & ~CFS_PAGE_MASK)
		return -EINVAL;

	env = cl_env_get(&refcheck);
	LASSERT(!IS_ERR(env));
	io = ccc_env_io(env)->cui_cl.cis_io;
	LASSERT(io != NULL);

	/* 0. Need locking between buffered and direct access. and race with
	 *    size changing by concurrent truncates and writes.
	 * 1. Need inode mutex to operate transient pages.
	 */
	if (rw == READ)
		mutex_lock(&inode->i_mutex);

	LASSERT(obj->cob_transient_pages == 0);
	for (seg = 0; seg < iter->nr_segs; seg++) {
		long iov_left = iter->iov[seg].iov_len;
		unsigned long user_addr = (unsigned long)iter->iov[seg].iov_base;

		if (rw == READ) {
			if (file_offset >= i_size_read(inode))
				break;
			if (file_offset + iov_left > i_size_read(inode))
				iov_left = i_size_read(inode) - file_offset;
		}

		while (iov_left > 0) {
			struct page **pages;
			int page_count, max_pages = 0;
			long bytes;

			bytes = min(size, iov_left);
			page_count = ll_get_user_pages(rw, user_addr, bytes,
						       &pages, &max_pages);
			if (likely(page_count > 0)) {
				if (unlikely(page_count <  max_pages))
					bytes = page_count << PAGE_CACHE_SHIFT;
				result = ll_direct_IO_26_seg(env, io, rw, inode,
							     file->f_mapping,
							     bytes, file_offset,
							     pages, page_count);
				ll_free_user_pages(pages, max_pages, rw==READ);
			} else if (page_count == 0) {
				GOTO(out, result = -EFAULT);
			} else {
				result = page_count;
			}
			if (unlikely(result <= 0)) {
				/* If we can't allocate a large enough buffer
				 * for the request, shrink it to a smaller
				 * PAGE_SIZE multiple and try again.
				 * We should always be able to kmalloc for a
				 * page worth of page pointers = 4MB on i386. */
				if (result == -ENOMEM &&
				    size > (PAGE_CACHE_SIZE / sizeof(*pages)) *
					   PAGE_CACHE_SIZE) {
					size = ((((size / 2) - 1) |
						 ~CFS_PAGE_MASK) + 1) &
						CFS_PAGE_MASK;
					CDEBUG(D_VFSTRACE,"DIO size now %lu\n",
					       size);
					continue;
				}

				GOTO(out, result);
			}

			tot_bytes += result;
			file_offset += result;
			iov_left -= result;
			user_addr += result;
		}
	}
out:
	LASSERT(obj->cob_transient_pages == 0);
	if (rw == READ)
		mutex_unlock(&inode->i_mutex);

	if (tot_bytes > 0) {
		if (rw == WRITE) {
			struct lov_stripe_md *lsm;

			lsm = ccc_inode_lsm_get(inode);
			LASSERT(lsm != NULL);
			lov_stripe_lock(lsm);
			obd_adjust_kms(ll_i2dtexp(inode), lsm, file_offset, 0);
			lov_stripe_unlock(lsm);
			ccc_inode_lsm_put(inode, lsm);
		}
	}

	cl_env_put(env, &refcheck);
	return tot_bytes ? : result;
}