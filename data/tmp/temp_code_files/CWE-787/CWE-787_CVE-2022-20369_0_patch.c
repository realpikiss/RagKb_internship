int v4l2_m2m_qbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,
		  struct v4l2_buffer *buf)
{
	struct video_device *vdev = video_devdata(file);
	struct vb2_queue *vq;
	int ret;

	vq = v4l2_m2m_get_vq(m2m_ctx, buf->type);
	if (V4L2_TYPE_IS_CAPTURE(vq->type) &&
	    (buf->flags & V4L2_BUF_FLAG_REQUEST_FD)) {
		dprintk("%s: requests cannot be used with capture buffers\n",
			__func__);
		return -EPERM;
	}

	ret = vb2_qbuf(vq, vdev->v4l2_dev->mdev, buf);
	if (ret)
		return ret;

	/* Adjust MMAP memory offsets for the CAPTURE queue */
	v4l2_m2m_adjust_mem_offset(vq, buf);

	/*
	 * If the capture queue is streaming, but streaming hasn't started
	 * on the device, but was asked to stop, mark the previously queued
	 * buffer as DONE with LAST flag since it won't be queued on the
	 * device.
	 */
	if (V4L2_TYPE_IS_CAPTURE(vq->type) &&
	    vb2_is_streaming(vq) && !vb2_start_streaming_called(vq) &&
	   (v4l2_m2m_has_stopped(m2m_ctx) || v4l2_m2m_dst_buf_is_last(m2m_ctx)))
		v4l2_m2m_force_last_buf_done(m2m_ctx, vq);
	else if (!(buf->flags & V4L2_BUF_FLAG_IN_REQUEST))
		v4l2_m2m_try_schedule(m2m_ctx);

	return 0;
}