void GPIOChangeRFWorkItemCallBack(struct work_struct *work)
{
	struct ieee80211_device *ieee = container_of(work, struct ieee80211_device, GPIOChangeRFWorkItem.work);
	struct net_device *dev = ieee->dev;
	struct r8180_priv *priv = ieee80211_priv(dev);
	u8 btPSR;
	u8 btConfig0;
	RT_RF_POWER_STATE	eRfPowerStateToSet;
	bool bActuallySet = false;

	char *argv[3];
	static char *RadioPowerPath = "/etc/acpi/events/RadioPower.sh";
	static char *envp[] = {"HOME=/", "TERM=linux", "PATH=/usr/bin:/bin", NULL};
	static int readf_count = 0;

	if (readf_count % 10 == 0)
		priv->PowerProfile = read_acadapter_file("/proc/acpi/ac_adapter/AC0/state");

	readf_count = (readf_count+1)%0xffff;
	/* We should turn off LED before polling FF51[4]. */

	/* Turn off LED. */
	btPSR = read_nic_byte(dev, PSR);
	write_nic_byte(dev, PSR, (btPSR & ~BIT3));

	/* It need to delay 4us suggested by Jong, 2008-01-16 */
	udelay(4);

	/* HW radio On/Off according to the value of FF51[4](config0) */
	btConfig0 = btPSR = read_nic_byte(dev, CONFIG0);

	eRfPowerStateToSet = (btConfig0 & BIT4) ?  eRfOn : eRfOff;

	/* Turn LED back on when radio enabled */
	if (eRfPowerStateToSet == eRfOn)
		write_nic_byte(dev, PSR, btPSR | BIT3);

	if ((priv->ieee80211->bHwRadioOff == true) &&
	   (eRfPowerStateToSet == eRfOn)) {
		priv->ieee80211->bHwRadioOff = false;
		bActuallySet = true;
	} else if ((priv->ieee80211->bHwRadioOff == false) &&
		  (eRfPowerStateToSet == eRfOff)) {
		priv->ieee80211->bHwRadioOff = true;
		bActuallySet = true;
	}

	if (bActuallySet) {
		MgntActSet_RF_State(dev, eRfPowerStateToSet, RF_CHANGE_BY_HW);

		/* To update the UI status for Power status changed */
		if (priv->ieee80211->bHwRadioOff == true)
			argv[1] = "RFOFF";
		else
			argv[1] = "RFON";
		argv[0] = RadioPowerPath;
		argv[2] = NULL;

		call_usermodehelper(RadioPowerPath, argv, envp, 1);
	}
}