void dm_CheckRfCtrlGPIO(void *data)
{
	struct r8192_priv *priv = container_of_dwork_rsl(data,
				  struct r8192_priv, gpio_change_rf_wq);
	struct net_device *dev = priv->rtllib->dev;
	u8 tmp1byte;
	enum rt_rf_power_state eRfPowerStateToSet;
	bool bActuallySet = false;
	char *argv[3];
	static char *RadioPowerPath = "/etc/acpi/events/RadioPower.sh";
	static char *envp[] = {"HOME=/", "TERM=linux", "PATH=/usr/bin:/bin", NULL};

	bActuallySet = false;

	if ((priv->up_first_time == 1) || (priv->being_init_adapter))
		return;

	if (priv->bfirst_after_down) {
		priv->bfirst_after_down = 1;
		return;
	}

	tmp1byte = read_nic_byte(dev, GPI);

	eRfPowerStateToSet = (tmp1byte&BIT1) ?  eRfOn : eRfOff;

	if ((priv->bHwRadioOff == true) && (eRfPowerStateToSet == eRfOn)) {
		RT_TRACE(COMP_RF, "gpiochangeRF  - HW Radio ON\n");
		printk(KERN_INFO "gpiochangeRF  - HW Radio ON\n");
		priv->bHwRadioOff = false;
		bActuallySet = true;
	} else if ((priv->bHwRadioOff == false) && (eRfPowerStateToSet == eRfOff)) {
		RT_TRACE(COMP_RF, "gpiochangeRF  - HW Radio OFF\n");
		printk(KERN_INFO "gpiochangeRF  - HW Radio OFF\n");
		priv->bHwRadioOff = true;
		bActuallySet = true;
	}

	if (bActuallySet) {
		mdelay(1000);
		priv->bHwRfOffAction = 1;
		MgntActSet_RF_State(dev, eRfPowerStateToSet, RF_CHANGE_BY_HW, true);
		if (priv->bHwRadioOff == true)
			argv[1] = "RFOFF";
		else
			argv[1] = "RFON";

		argv[0] = RadioPowerPath;
		argv[2] = NULL;
		call_usermodehelper(RadioPowerPath, argv, envp, 1);
	}
}