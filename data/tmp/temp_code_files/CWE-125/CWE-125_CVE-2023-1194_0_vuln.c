struct lease_ctx_info *parse_lease_state(void *open_req)
{
	char *data_offset;
	struct create_context *cc;
	unsigned int next = 0;
	char *name;
	bool found = false;
	struct smb2_create_req *req = (struct smb2_create_req *)open_req;
	struct lease_ctx_info *lreq = kzalloc(sizeof(struct lease_ctx_info),
		GFP_KERNEL);
	if (!lreq)
		return NULL;

	data_offset = (char *)req + le32_to_cpu(req->CreateContextsOffset);
	cc = (struct create_context *)data_offset;
	do {
		cc = (struct create_context *)((char *)cc + next);
		name = le16_to_cpu(cc->NameOffset) + (char *)cc;
		if (le16_to_cpu(cc->NameLength) != 4 ||
		    strncmp(name, SMB2_CREATE_REQUEST_LEASE, 4)) {
			next = le32_to_cpu(cc->Next);
			continue;
		}
		found = true;
		break;
	} while (next != 0);

	if (found) {
		if (sizeof(struct lease_context_v2) == le32_to_cpu(cc->DataLength)) {
			struct create_lease_v2 *lc = (struct create_lease_v2 *)cc;

			memcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);
			lreq->req_state = lc->lcontext.LeaseState;
			lreq->flags = lc->lcontext.LeaseFlags;
			lreq->duration = lc->lcontext.LeaseDuration;
			memcpy(lreq->parent_lease_key, lc->lcontext.ParentLeaseKey,
			       SMB2_LEASE_KEY_SIZE);
			lreq->version = 2;
		} else {
			struct create_lease *lc = (struct create_lease *)cc;

			memcpy(lreq->lease_key, lc->lcontext.LeaseKey, SMB2_LEASE_KEY_SIZE);
			lreq->req_state = lc->lcontext.LeaseState;
			lreq->flags = lc->lcontext.LeaseFlags;
			lreq->duration = lc->lcontext.LeaseDuration;
			lreq->version = 1;
		}
		return lreq;
	}

	kfree(lreq);
	return NULL;
}