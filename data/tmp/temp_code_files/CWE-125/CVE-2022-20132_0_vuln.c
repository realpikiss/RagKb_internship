static int logi_dj_probe(struct hid_device *hdev,
			 const struct hid_device_id *id)
{
	struct hid_report_enum *rep_enum;
	struct hid_report *rep;
	struct dj_receiver_dev *djrcv_dev;
	struct usb_interface *intf;
	unsigned int no_dj_interfaces = 0;
	bool has_hidpp = false;
	unsigned long flags;
	int retval;

	/*
	 * Call to usbhid to fetch the HID descriptors of the current
	 * interface subsequently call to the hid/hid-core to parse the
	 * fetched descriptors.
	 */
	retval = hid_parse(hdev);
	if (retval) {
		hid_err(hdev, "%s: parse failed\n", __func__);
		return retval;
	}

	/*
	 * Some KVMs add an extra interface for e.g. mouse emulation. If we
	 * treat these as logitech-dj interfaces then this causes input events
	 * reported through this extra interface to not be reported correctly.
	 * To avoid this, we treat these as generic-hid devices.
	 */
	switch (id->driver_data) {
	case recvr_type_dj:		no_dj_interfaces = 3; break;
	case recvr_type_hidpp:		no_dj_interfaces = 2; break;
	case recvr_type_gaming_hidpp:	no_dj_interfaces = 3; break;
	case recvr_type_mouse_only:	no_dj_interfaces = 2; break;
	case recvr_type_27mhz:		no_dj_interfaces = 2; break;
	case recvr_type_bluetooth:	no_dj_interfaces = 2; break;
	case recvr_type_dinovo:		no_dj_interfaces = 2; break;
	}
	if (hid_is_using_ll_driver(hdev, &usb_hid_driver)) {
		intf = to_usb_interface(hdev->dev.parent);
		if (intf && intf->altsetting->desc.bInterfaceNumber >=
							no_dj_interfaces) {
			hdev->quirks |= HID_QUIRK_INPUT_PER_APP;
			return hid_hw_start(hdev, HID_CONNECT_DEFAULT);
		}
	}

	rep_enum = &hdev->report_enum[HID_INPUT_REPORT];

	/* no input reports, bail out */
	if (list_empty(&rep_enum->report_list))
		return -ENODEV;

	/*
	 * Check for the HID++ application.
	 * Note: we should theoretically check for HID++ and DJ
	 * collections, but this will do.
	 */
	list_for_each_entry(rep, &rep_enum->report_list, list) {
		if (rep->application == 0xff000001)
			has_hidpp = true;
	}

	/*
	 * Ignore interfaces without DJ/HID++ collection, they will not carry
	 * any data, dont create any hid_device for them.
	 */
	if (!has_hidpp && id->driver_data == recvr_type_dj)
		return -ENODEV;

	/* get the current application attached to the node */
	rep = list_first_entry(&rep_enum->report_list, struct hid_report, list);
	djrcv_dev = dj_get_receiver_dev(hdev, id->driver_data,
					rep->application, has_hidpp);
	if (!djrcv_dev) {
		hid_err(hdev, "%s: dj_get_receiver_dev failed\n", __func__);
		return -ENOMEM;
	}

	if (!rep_enum->numbered)
		djrcv_dev->unnumbered_application = rep->application;

	/* Starts the usb device and connects to upper interfaces hiddev and
	 * hidraw */
	retval = hid_hw_start(hdev, HID_CONNECT_HIDRAW|HID_CONNECT_HIDDEV);
	if (retval) {
		hid_err(hdev, "%s: hid_hw_start returned error\n", __func__);
		goto hid_hw_start_fail;
	}

	if (has_hidpp) {
		retval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);
		if (retval < 0) {
			hid_err(hdev, "%s: logi_dj_recv_switch_to_dj_mode returned error:%d\n",
				__func__, retval);
			goto switch_to_dj_mode_fail;
		}
	}

	/* This is enabling the polling urb on the IN endpoint */
	retval = hid_hw_open(hdev);
	if (retval < 0) {
		hid_err(hdev, "%s: hid_hw_open returned error:%d\n",
			__func__, retval);
		goto llopen_failed;
	}

	/* Allow incoming packets to arrive: */
	hid_device_io_start(hdev);

	if (has_hidpp) {
		spin_lock_irqsave(&djrcv_dev->lock, flags);
		djrcv_dev->ready = true;
		spin_unlock_irqrestore(&djrcv_dev->lock, flags);
		retval = logi_dj_recv_query_paired_devices(djrcv_dev);
		if (retval < 0) {
			hid_err(hdev, "%s: logi_dj_recv_query_paired_devices error:%d\n",
				__func__, retval);
			/*
			 * This can happen with a KVM, let the probe succeed,
			 * logi_dj_recv_queue_unknown_work will retry later.
			 */
		}
	}

	return 0;

llopen_failed:
switch_to_dj_mode_fail:
	hid_hw_stop(hdev);

hid_hw_start_fail:
	dj_put_receiver_dev(hdev);
	return retval;
}