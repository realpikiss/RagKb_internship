static struct nft_trans_gc *nft_trans_gc_catchall(struct nft_trans_gc *gc,
						  unsigned int gc_seq,
						  bool sync)
{
	struct nft_set_elem_catchall *catchall;
	const struct nft_set *set = gc->set;
	struct nft_set_ext *ext;

	list_for_each_entry_rcu(catchall, &set->catchall_list, list) {
		ext = nft_set_elem_ext(set, catchall->elem);

		if (!nft_set_elem_expired(ext))
			continue;
		if (nft_set_elem_is_dead(ext))
			goto dead_elem;

		nft_set_elem_dead(ext);
dead_elem:
		if (sync)
			gc = nft_trans_gc_queue_sync(gc, GFP_ATOMIC);
		else
			gc = nft_trans_gc_queue_async(gc, gc_seq, GFP_ATOMIC);

		if (!gc)
			return NULL;

		nft_trans_gc_elem_add(gc, catchall->elem);
	}

	return gc;
}