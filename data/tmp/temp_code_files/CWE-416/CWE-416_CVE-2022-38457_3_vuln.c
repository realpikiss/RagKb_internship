static int vmw_cmd_set_shader(struct vmw_private *dev_priv,
			      struct vmw_sw_context *sw_context,
			      SVGA3dCmdHeader *header)
{
	VMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdSetShader);
	struct vmw_ctx_bindinfo_shader binding;
	struct vmw_resource *ctx, *res = NULL;
	struct vmw_ctx_validation_info *ctx_info;
	int ret;

	cmd = container_of(header, typeof(*cmd), header);

	if (cmd->body.type >= SVGA3D_SHADERTYPE_PREDX_MAX) {
		VMW_DEBUG_USER("Illegal shader type %u.\n",
			       (unsigned int) cmd->body.type);
		return -EINVAL;
	}

	ret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,
				VMW_RES_DIRTY_SET, user_context_converter,
				&cmd->body.cid, &ctx);
	if (unlikely(ret != 0))
		return ret;

	if (!dev_priv->has_mob)
		return 0;

	if (cmd->body.shid != SVGA3D_INVALID_ID) {
		/*
		 * This is the compat shader path - Per device guest-backed
		 * shaders, but user-space thinks it's per context host-
		 * backed shaders.
		 */
		res = vmw_shader_lookup(vmw_context_res_man(ctx),
					cmd->body.shid, cmd->body.type);
		if (!IS_ERR(res)) {
			ret = vmw_execbuf_res_noctx_val_add(sw_context, res,
							    VMW_RES_DIRTY_NONE);
			if (unlikely(ret != 0))
				return ret;

			ret = vmw_resource_relocation_add
				(sw_context, res,
				 vmw_ptr_diff(sw_context->buf_start,
					      &cmd->body.shid),
				 vmw_res_rel_normal);
			if (unlikely(ret != 0))
				return ret;
		}
	}

	if (IS_ERR_OR_NULL(res)) {
		ret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_shader,
					VMW_RES_DIRTY_NONE,
					user_shader_converter, &cmd->body.shid,
					&res);
		if (unlikely(ret != 0))
			return ret;
	}

	ctx_info = vmw_execbuf_info_from_res(sw_context, ctx);
	if (!ctx_info)
		return -EINVAL;

	binding.bi.ctx = ctx;
	binding.bi.res = res;
	binding.bi.bt = vmw_ctx_binding_shader;
	binding.shader_slot = cmd->body.type - SVGA3D_SHADERTYPE_MIN;
	vmw_binding_add(ctx_info->staged, &binding.bi, binding.shader_slot, 0);

	return 0;
}