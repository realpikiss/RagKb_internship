static int nfsd4_do_async_copy(void *data)
{
	struct nfsd4_copy *copy = (struct nfsd4_copy *)data;
	__be32 nfserr;

	if (nfsd4_ssc_is_inter(copy)) {
		struct file *filp;

		filp = nfs42_ssc_open(copy->ss_mnt, &copy->c_fh,
				      &copy->stateid);
		if (IS_ERR(filp)) {
			switch (PTR_ERR(filp)) {
			case -EBADF:
				nfserr = nfserr_wrong_type;
				break;
			default:
				nfserr = nfserr_offload_denied;
			}
			nfsd4_interssc_disconnect(copy->ss_mnt);
			goto do_callback;
		}
		nfserr = nfsd4_do_copy(copy, filp, copy->nf_dst->nf_file,
				       false);
		nfsd4_cleanup_inter_ssc(copy->ss_mnt, filp, copy->nf_dst);
	} else {
		nfserr = nfsd4_do_copy(copy, copy->nf_src->nf_file,
				       copy->nf_dst->nf_file, false);
		nfsd4_cleanup_intra_ssc(copy->nf_src, copy->nf_dst);
	}

do_callback:
	nfsd4_send_cb_offload(copy, nfserr);
	cleanup_async_copy(copy);
	return 0;
}