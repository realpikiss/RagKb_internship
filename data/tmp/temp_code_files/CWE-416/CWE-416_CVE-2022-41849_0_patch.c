static void ufx_usb_disconnect(struct usb_interface *interface)
{
	struct ufx_data *dev;

	mutex_lock(&disconnect_mutex);

	dev = usb_get_intfdata(interface);

	pr_debug("USB disconnect starting\n");

	/* we virtualize until all fb clients release. Then we free */
	dev->virtualized = true;

	/* When non-active we'll update virtual framebuffer, but no new urbs */
	atomic_set(&dev->usb_active, 0);

	usb_set_intfdata(interface, NULL);

	/* if clients still have us open, will be freed on last close */
	if (dev->fb_count == 0)
		schedule_delayed_work(&dev->free_framebuffer_work, 0);

	/* release reference taken by kref_init in probe() */
	kref_put(&dev->kref, ufx_free);

	/* consider ufx_data freed */

	mutex_unlock(&disconnect_mutex);
}