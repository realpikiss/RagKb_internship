static struct nft_trans_gc *nft_trans_gc_catchall(struct nft_trans_gc *gc,
						  unsigned int gc_seq,
						  bool sync)
{
	struct nft_set_elem_catchall *catchall, *next;
	const struct nft_set *set = gc->set;
	struct nft_elem_priv *elem_priv;
	struct nft_set_ext *ext;

	list_for_each_entry_safe(catchall, next, &set->catchall_list, list) {
		ext = nft_set_elem_ext(set, catchall->elem);

		if (!nft_set_elem_expired(ext))
			continue;
		if (nft_set_elem_is_dead(ext))
			goto dead_elem;

		nft_set_elem_dead(ext);
dead_elem:
		if (sync)
			gc = nft_trans_gc_queue_sync(gc, GFP_ATOMIC);
		else
			gc = nft_trans_gc_queue_async(gc, gc_seq, GFP_ATOMIC);

		if (!gc)
			return NULL;

		elem_priv = catchall->elem;
		if (sync) {
			nft_setelem_data_deactivate(gc->net, gc->set, elem_priv);
			nft_setelem_catchall_destroy(catchall);
		}

		nft_trans_gc_elem_add(gc, elem_priv);
	}

	return gc;
}