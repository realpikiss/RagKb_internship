int add_watch_to_object(struct watch *watch, struct watch_list *wlist)
{
	struct watch_queue *wqueue = rcu_access_pointer(watch->queue);
	struct watch *w;

	hlist_for_each_entry(w, &wlist->watchers, list_node) {
		struct watch_queue *wq = rcu_access_pointer(w->queue);
		if (wqueue == wq && watch->id == w->id)
			return -EBUSY;
	}

	watch->cred = get_current_cred();
	rcu_assign_pointer(watch->watch_list, wlist);

	if (atomic_inc_return(&watch->cred->user->nr_watches) >
	    task_rlimit(current, RLIMIT_NOFILE)) {
		atomic_dec(&watch->cred->user->nr_watches);
		put_cred(watch->cred);
		return -EAGAIN;
	}

	spin_lock_bh(&wqueue->lock);
	kref_get(&wqueue->usage);
	kref_get(&watch->usage);
	hlist_add_head(&watch->queue_node, &wqueue->watches);
	spin_unlock_bh(&wqueue->lock);

	hlist_add_head(&watch->list_node, &wlist->watchers);
	return 0;
}