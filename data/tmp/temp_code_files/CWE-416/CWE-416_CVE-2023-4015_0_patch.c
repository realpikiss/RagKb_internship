static void nft_immediate_deactivate(const struct nft_ctx *ctx,
				     const struct nft_expr *expr,
				     enum nft_trans_phase phase)
{
	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
	const struct nft_data *data = &priv->data;
	struct nft_chain *chain;

	if (priv->dreg == NFT_REG_VERDICT) {
		switch (data->verdict.code) {
		case NFT_JUMP:
		case NFT_GOTO:
			chain = data->verdict.chain;
			if (!nft_chain_binding(chain))
				break;

			switch (phase) {
			case NFT_TRANS_PREPARE_ERROR:
				nf_tables_unbind_chain(ctx, chain);
				nft_deactivate_next(ctx->net, chain);
				break;
			case NFT_TRANS_PREPARE:
				nft_immediate_chain_deactivate(ctx, chain, phase);
				nft_deactivate_next(ctx->net, chain);
				break;
			default:
				nft_immediate_chain_deactivate(ctx, chain, phase);
				nft_chain_del(chain);
				chain->bound = false;
				nft_use_dec(&chain->table->use);
				break;
			}
			break;
		default:
			break;
		}
	}

	if (phase == NFT_TRANS_COMMIT)
		return;

	return nft_data_release(&priv->data, nft_dreg_to_type(priv->dreg));
}