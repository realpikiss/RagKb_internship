static int vmw_cmd_dx_set_shader(struct vmw_private *dev_priv,
				 struct vmw_sw_context *sw_context,
				 SVGA3dCmdHeader *header)
{
	VMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXSetShader);
	SVGA3dShaderType max_allowed = has_sm5_context(dev_priv) ?
		SVGA3D_SHADERTYPE_MAX : SVGA3D_SHADERTYPE_DX10_MAX;
	struct vmw_resource *res = NULL;
	struct vmw_ctx_validation_info *ctx_node = VMW_GET_CTX_NODE(sw_context);
	struct vmw_ctx_bindinfo_shader binding;
	int ret = 0;

	if (!ctx_node)
		return -EINVAL;

	cmd = container_of(header, typeof(*cmd), header);

	if (cmd->body.type >= max_allowed ||
	    cmd->body.type < SVGA3D_SHADERTYPE_MIN) {
		VMW_DEBUG_USER("Illegal shader type %u.\n",
			       (unsigned int) cmd->body.type);
		return -EINVAL;
	}

	if (cmd->body.shaderId != SVGA3D_INVALID_ID) {
		res = vmw_shader_lookup(sw_context->man, cmd->body.shaderId, 0);
		if (IS_ERR(res)) {
			VMW_DEBUG_USER("Could not find shader for binding.\n");
			return PTR_ERR(res);
		}

		ret = vmw_execbuf_res_noctx_val_add(sw_context, res,
						    VMW_RES_DIRTY_NONE);
		if (ret)
			return ret;
	}

	binding.bi.ctx = ctx_node->ctx;
	binding.bi.res = res;
	binding.bi.bt = vmw_ctx_binding_dx_shader;
	binding.shader_slot = cmd->body.type - SVGA3D_SHADERTYPE_MIN;

	vmw_binding_add(ctx_node->staged, &binding.bi, binding.shader_slot, 0);

	return 0;
}