static void io_poll_remove_entries(struct io_kiocb *req)
{
	struct io_poll_iocb *poll = io_poll_get_single(req);
	struct io_poll_iocb *poll_double = io_poll_get_double(req);

	/*
	 * While we hold the waitqueue lock and the waitqueue is nonempty,
	 * wake_up_pollfree() will wait for us.  However, taking the waitqueue
	 * lock in the first place can race with the waitqueue being freed.
	 *
	 * We solve this as eventpoll does: by taking advantage of the fact that
	 * all users of wake_up_pollfree() will RCU-delay the actual free.  If
	 * we enter rcu_read_lock() and see that the pointer to the queue is
	 * non-NULL, we can then lock it without the memory being freed out from
	 * under us.
	 *
	 * Keep holding rcu_read_lock() as long as we hold the queue lock, in
	 * case the caller deletes the entry from the queue, leaving it empty.
	 * In that case, only RCU prevents the queue memory from being freed.
	 */
	rcu_read_lock();
	io_poll_remove_entry(poll);
	if (poll_double)
		io_poll_remove_entry(poll_double);
	rcu_read_unlock();
}