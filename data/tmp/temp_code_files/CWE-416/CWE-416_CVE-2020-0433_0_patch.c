void blk_mq_queue_tag_busy_iter(struct request_queue *q, busy_iter_fn *fn,
		void *priv)
{
	struct blk_mq_hw_ctx *hctx;
	int i;

	/*
	 * __blk_mq_update_nr_hw_queues will update the nr_hw_queues and
	 * queue_hw_ctx after freeze the queue. So we could use q_usage_counter
	 * to avoid race with it. __blk_mq_update_nr_hw_queues will users
	 * synchronize_rcu to ensure all of the users go out of the critical
	 * section below and see zeroed q_usage_counter.
	 */
	rcu_read_lock();
	if (percpu_ref_is_zero(&q->q_usage_counter)) {
		rcu_read_unlock();
		return;
	}

	queue_for_each_hw_ctx(q, hctx, i) {
		struct blk_mq_tags *tags = hctx->tags;

		/*
		 * If not software queues are currently mapped to this
		 * hardware queue, there's nothing to check
		 */
		if (!blk_mq_hw_queue_mapped(hctx))
			continue;

		if (tags->nr_reserved_tags)
			bt_for_each(hctx, &tags->breserved_tags, fn, priv, true);
		bt_for_each(hctx, &tags->bitmap_tags, fn, priv, false);
	}
	rcu_read_unlock();
}