static int vmw_cmd_dx_bind_shader(struct vmw_private *dev_priv,
				  struct vmw_sw_context *sw_context,
				  SVGA3dCmdHeader *header)
{
	struct vmw_resource *ctx;
	struct vmw_resource *res;
	VMW_DECLARE_CMD_VAR(*cmd, SVGA3dCmdDXBindShader) =
		container_of(header, typeof(*cmd), header);
	int ret;

	if (cmd->body.cid != SVGA3D_INVALID_ID) {
		ret = vmw_cmd_res_check(dev_priv, sw_context, vmw_res_context,
					VMW_RES_DIRTY_SET,
					user_context_converter, &cmd->body.cid,
					&ctx);
		if (ret)
			return ret;
	} else {
		struct vmw_ctx_validation_info *ctx_node =
			VMW_GET_CTX_NODE(sw_context);

		if (!ctx_node)
			return -EINVAL;

		ctx = ctx_node->ctx;
	}

	res = vmw_shader_lookup(vmw_context_res_man(ctx), cmd->body.shid, 0);
	if (IS_ERR(res)) {
		VMW_DEBUG_USER("Could not find shader to bind.\n");
		return PTR_ERR(res);
	}

	ret = vmw_execbuf_res_val_add(sw_context, res, VMW_RES_DIRTY_NONE,
				      vmw_val_add_flag_noctx);
	if (ret) {
		VMW_DEBUG_USER("Error creating resource validation node.\n");
		return ret;
	}

	return vmw_cmd_res_switch_backup(dev_priv, sw_context, res,
					 &cmd->body.mobid,
					 cmd->body.offsetInBytes);
}