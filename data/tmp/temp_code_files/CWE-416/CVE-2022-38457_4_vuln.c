static int vmw_resource_context_res_add(struct vmw_private *dev_priv,
					struct vmw_sw_context *sw_context,
					struct vmw_resource *ctx)
{
	struct list_head *binding_list;
	struct vmw_ctx_bindinfo *entry;
	int ret = 0;
	struct vmw_resource *res;
	u32 i;
	u32 cotable_max = has_sm5_context(ctx->dev_priv) ?
		SVGA_COTABLE_MAX : SVGA_COTABLE_DX10_MAX;

	/* Add all cotables to the validation list. */
	if (has_sm4_context(dev_priv) &&
	    vmw_res_type(ctx) == vmw_res_dx_context) {
		for (i = 0; i < cotable_max; ++i) {
			res = vmw_context_cotable(ctx, i);
			if (IS_ERR(res))
				continue;

			ret = vmw_execbuf_res_noctx_val_add(sw_context, res,
							    VMW_RES_DIRTY_SET);
			if (unlikely(ret != 0))
				return ret;
		}
	}

	/* Add all resources bound to the context to the validation list */
	mutex_lock(&dev_priv->binding_mutex);
	binding_list = vmw_context_binding_list(ctx);

	list_for_each_entry(entry, binding_list, ctx_list) {
		if (vmw_res_type(entry->res) == vmw_res_view)
			ret = vmw_view_res_val_add(sw_context, entry->res);
		else
			ret = vmw_execbuf_res_noctx_val_add
				(sw_context, entry->res,
				 vmw_binding_dirtying(entry->bt));
		if (unlikely(ret != 0))
			break;
	}

	if (has_sm4_context(dev_priv) &&
	    vmw_res_type(ctx) == vmw_res_dx_context) {
		struct vmw_buffer_object *dx_query_mob;

		dx_query_mob = vmw_context_get_dx_query_mob(ctx);
		if (dx_query_mob)
			ret = vmw_validation_add_bo(sw_context->ctx,
						    dx_query_mob, true, false);
	}

	mutex_unlock(&dev_priv->binding_mutex);
	return ret;
}