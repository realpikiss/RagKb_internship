static int mptcp_disconnect(struct sock *sk, int flags)
{
	struct mptcp_subflow_context *subflow;
	struct mptcp_sock *msk = mptcp_sk(sk);

	inet_sk_state_store(sk, TCP_CLOSE);

	mptcp_for_each_subflow(msk, subflow) {
		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);

		__mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_FASTCLOSE);
	}

	mptcp_stop_timer(sk);
	sk_stop_timer(sk, &sk->sk_timer);

	if (mptcp_sk(sk)->token)
		mptcp_event(MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL);

	mptcp_destroy_common(msk);
	msk->last_snd = NULL;
	WRITE_ONCE(msk->flags, 0);
	msk->cb_flags = 0;
	msk->push_pending = 0;
	msk->recovery = false;
	msk->can_ack = false;
	msk->fully_established = false;
	msk->rcv_data_fin = false;
	msk->snd_data_fin_enable = false;
	msk->rcv_fastclose = false;
	msk->use_64bit_ack = false;
	WRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk)));
	mptcp_pm_data_reset(msk);
	mptcp_ca_reset(sk);

	sk->sk_shutdown = 0;
	sk_error_report(sk);
	return 0;
}