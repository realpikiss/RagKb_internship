static int novatd_frontend_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_usb_device *dev = adap->dev;
	struct dib0700_state *st = dev->priv;
	struct dib0700_adapter_state *state = adap->priv;

	if (!dvb_attach(dib7000p_attach, &state->dib7000p_ops))
		return -ENODEV;

	if (adap->id == 0) {
		stk7070pd_init(dev);

		/* turn the power LED on, the other two off (just in case) */
		dib0700_set_gpio(dev, GPIO0, GPIO_OUT, 0);
		dib0700_set_gpio(dev, GPIO1, GPIO_OUT, 0);
		dib0700_set_gpio(dev, GPIO2, GPIO_OUT, 1);

		if (state->dib7000p_ops.i2c_enumeration(&dev->i2c_adap, 2, 18,
					     stk7070pd_dib7000p_config) != 0) {
			err("%s: state->dib7000p_ops.i2c_enumeration failed.  Cannot continue\n",
			    __func__);
			dvb_detach(state->dib7000p_ops.set_wbd_ref);
			return -ENODEV;
		}
	}

	adap->fe_adap[0].fe = state->dib7000p_ops.init(&dev->i2c_adap,
			adap->id == 0 ? 0x80 : 0x82,
			&stk7070pd_dib7000p_config[adap->id]);

	if (adap->fe_adap[0].fe == NULL)
		return -ENODEV;

	st->read_status = adap->fe_adap[0].fe->ops.read_status;
	adap->fe_adap[0].fe->ops.read_status = novatd_read_status_override;
	st->sleep = adap->fe_adap[0].fe->ops.sleep;
	adap->fe_adap[0].fe->ops.sleep = novatd_sleep_override;

	return 0;
}