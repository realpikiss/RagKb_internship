static int do_tls_getsockopt_conf(struct sock *sk, char __user *optval,
				  int __user *optlen, int tx)
{
	int rc = 0;
	struct tls_context *ctx = tls_get_ctx(sk);
	struct tls_crypto_info *crypto_info;
	struct cipher_context *cctx;
	int len;

	if (get_user(len, optlen))
		return -EFAULT;

	if (!optval || (len < sizeof(*crypto_info))) {
		rc = -EINVAL;
		goto out;
	}

	if (!ctx) {
		rc = -EBUSY;
		goto out;
	}

	/* get user crypto info */
	if (tx) {
		crypto_info = &ctx->crypto_send.info;
		cctx = &ctx->tx;
	} else {
		crypto_info = &ctx->crypto_recv.info;
		cctx = &ctx->rx;
	}

	if (!TLS_CRYPTO_INFO_READY(crypto_info)) {
		rc = -EBUSY;
		goto out;
	}

	if (len == sizeof(*crypto_info)) {
		if (copy_to_user(optval, crypto_info, sizeof(*crypto_info)))
			rc = -EFAULT;
		goto out;
	}

	switch (crypto_info->cipher_type) {
	case TLS_CIPHER_AES_GCM_128: {
		struct tls12_crypto_info_aes_gcm_128 *
		  crypto_info_aes_gcm_128 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aes_gcm_128,
			       info);

		if (len != sizeof(*crypto_info_aes_gcm_128)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(crypto_info_aes_gcm_128->iv,
		       cctx->iv + TLS_CIPHER_AES_GCM_128_SALT_SIZE,
		       TLS_CIPHER_AES_GCM_128_IV_SIZE);
		memcpy(crypto_info_aes_gcm_128->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_AES_GCM_128_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval,
				 crypto_info_aes_gcm_128,
				 sizeof(*crypto_info_aes_gcm_128)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_AES_GCM_256: {
		struct tls12_crypto_info_aes_gcm_256 *
		  crypto_info_aes_gcm_256 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aes_gcm_256,
			       info);

		if (len != sizeof(*crypto_info_aes_gcm_256)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(crypto_info_aes_gcm_256->iv,
		       cctx->iv + TLS_CIPHER_AES_GCM_256_SALT_SIZE,
		       TLS_CIPHER_AES_GCM_256_IV_SIZE);
		memcpy(crypto_info_aes_gcm_256->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_AES_GCM_256_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval,
				 crypto_info_aes_gcm_256,
				 sizeof(*crypto_info_aes_gcm_256)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_AES_CCM_128: {
		struct tls12_crypto_info_aes_ccm_128 *aes_ccm_128 =
			container_of(crypto_info,
				struct tls12_crypto_info_aes_ccm_128, info);

		if (len != sizeof(*aes_ccm_128)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(aes_ccm_128->iv,
		       cctx->iv + TLS_CIPHER_AES_CCM_128_SALT_SIZE,
		       TLS_CIPHER_AES_CCM_128_IV_SIZE);
		memcpy(aes_ccm_128->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_AES_CCM_128_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval, aes_ccm_128, sizeof(*aes_ccm_128)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_CHACHA20_POLY1305: {
		struct tls12_crypto_info_chacha20_poly1305 *chacha20_poly1305 =
			container_of(crypto_info,
				struct tls12_crypto_info_chacha20_poly1305,
				info);

		if (len != sizeof(*chacha20_poly1305)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(chacha20_poly1305->iv,
		       cctx->iv + TLS_CIPHER_CHACHA20_POLY1305_SALT_SIZE,
		       TLS_CIPHER_CHACHA20_POLY1305_IV_SIZE);
		memcpy(chacha20_poly1305->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_CHACHA20_POLY1305_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval, chacha20_poly1305,
				sizeof(*chacha20_poly1305)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_SM4_GCM: {
		struct tls12_crypto_info_sm4_gcm *sm4_gcm_info =
			container_of(crypto_info,
				struct tls12_crypto_info_sm4_gcm, info);

		if (len != sizeof(*sm4_gcm_info)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(sm4_gcm_info->iv,
		       cctx->iv + TLS_CIPHER_SM4_GCM_SALT_SIZE,
		       TLS_CIPHER_SM4_GCM_IV_SIZE);
		memcpy(sm4_gcm_info->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_SM4_GCM_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval, sm4_gcm_info, sizeof(*sm4_gcm_info)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_SM4_CCM: {
		struct tls12_crypto_info_sm4_ccm *sm4_ccm_info =
			container_of(crypto_info,
				struct tls12_crypto_info_sm4_ccm, info);

		if (len != sizeof(*sm4_ccm_info)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(sm4_ccm_info->iv,
		       cctx->iv + TLS_CIPHER_SM4_CCM_SALT_SIZE,
		       TLS_CIPHER_SM4_CCM_IV_SIZE);
		memcpy(sm4_ccm_info->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_SM4_CCM_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval, sm4_ccm_info, sizeof(*sm4_ccm_info)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_ARIA_GCM_128: {
		struct tls12_crypto_info_aria_gcm_128 *
		  crypto_info_aria_gcm_128 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aria_gcm_128,
			       info);

		if (len != sizeof(*crypto_info_aria_gcm_128)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(crypto_info_aria_gcm_128->iv,
		       cctx->iv + TLS_CIPHER_ARIA_GCM_128_SALT_SIZE,
		       TLS_CIPHER_ARIA_GCM_128_IV_SIZE);
		memcpy(crypto_info_aria_gcm_128->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_ARIA_GCM_128_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval,
				 crypto_info_aria_gcm_128,
				 sizeof(*crypto_info_aria_gcm_128)))
			rc = -EFAULT;
		break;
	}
	case TLS_CIPHER_ARIA_GCM_256: {
		struct tls12_crypto_info_aria_gcm_256 *
		  crypto_info_aria_gcm_256 =
		  container_of(crypto_info,
			       struct tls12_crypto_info_aria_gcm_256,
			       info);

		if (len != sizeof(*crypto_info_aria_gcm_256)) {
			rc = -EINVAL;
			goto out;
		}
		lock_sock(sk);
		memcpy(crypto_info_aria_gcm_256->iv,
		       cctx->iv + TLS_CIPHER_ARIA_GCM_256_SALT_SIZE,
		       TLS_CIPHER_ARIA_GCM_256_IV_SIZE);
		memcpy(crypto_info_aria_gcm_256->rec_seq, cctx->rec_seq,
		       TLS_CIPHER_ARIA_GCM_256_REC_SEQ_SIZE);
		release_sock(sk);
		if (copy_to_user(optval,
				 crypto_info_aria_gcm_256,
				 sizeof(*crypto_info_aria_gcm_256)))
			rc = -EFAULT;
		break;
	}
	default:
		rc = -EINVAL;
	}

out:
	return rc;
}