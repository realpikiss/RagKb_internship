static int
call_ad(struct net *net, struct sock *ctnl, struct sk_buff *skb,
	struct ip_set *set, struct nlattr *tb[], enum ipset_adt adt,
	u32 flags, bool use_lineno)
{
	int ret;
	u32 lineno = 0;
	bool eexist = flags & IPSET_FLAG_EXIST, retried = false;

	do {
		if (retried) {
			__ip_set_get(set);
			nfnl_unlock(NFNL_SUBSYS_IPSET);
			cond_resched();
			nfnl_lock(NFNL_SUBSYS_IPSET);
			__ip_set_put(set);
		}

		ip_set_lock(set);
		ret = set->variant->uadt(set, tb, adt, &lineno, flags, retried);
		ip_set_unlock(set);
		retried = true;
	} while (ret == -ERANGE ||
		 (ret == -EAGAIN &&
		  set->variant->resize &&
		  (ret = set->variant->resize(set, retried)) == 0));

	if (!ret || (ret == -IPSET_ERR_EXIST && eexist))
		return 0;
	if (lineno && use_lineno) {
		/* Error in restore/batch mode: send back lineno */
		struct nlmsghdr *rep, *nlh = nlmsg_hdr(skb);
		struct sk_buff *skb2;
		struct nlmsgerr *errmsg;
		size_t payload = min(SIZE_MAX,
				     sizeof(*errmsg) + nlmsg_len(nlh));
		int min_len = nlmsg_total_size(sizeof(struct nfgenmsg));
		struct nlattr *cda[IPSET_ATTR_CMD_MAX + 1];
		struct nlattr *cmdattr;
		u32 *errline;

		skb2 = nlmsg_new(payload, GFP_KERNEL);
		if (!skb2)
			return -ENOMEM;
		rep = nlmsg_put(skb2, NETLINK_CB(skb).portid,
				nlh->nlmsg_seq, NLMSG_ERROR, payload, 0);
		errmsg = nlmsg_data(rep);
		errmsg->error = ret;
		unsafe_memcpy(&errmsg->msg, nlh, nlh->nlmsg_len,
			      /* Bounds checked by the skb layer. */);

		cmdattr = (void *)&errmsg->msg + min_len;

		ret = nla_parse(cda, IPSET_ATTR_CMD_MAX, cmdattr,
				nlh->nlmsg_len - min_len, ip_set_adt_policy,
				NULL);

		if (ret) {
			nlmsg_free(skb2);
			return ret;
		}
		errline = nla_data(cda[IPSET_ATTR_LINENO]);

		*errline = lineno;

		nfnetlink_unicast(skb2, net, NETLINK_CB(skb).portid);
		/* Signal netlink not to send its ACK/errmsg.  */
		return -EINTR;
	}

	return ret;
}