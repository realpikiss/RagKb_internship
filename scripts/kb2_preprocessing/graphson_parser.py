"""
GraphSON v3 TinkerPop Parser for Joern CPG

This module provides utilities for parsing and validating GraphSON v3 format
generated by Joern for Code Property Graphs (CPG).
"""

import json
from pathlib import Path
from collections import Counter
from typing import Dict, List, Tuple, Optional, Any


class GraphSONParser:
    """Parser for GraphSON v3 TinkerPop format (Joern CPG)"""
    
    # Expected Joern CPG types
    EXPECTED_VERTEX_TYPES = [
        'METHOD', 'CALL', 'IDENTIFIER', 'LITERAL', 'RETURN', 
        'BLOCK', 'CONTROL_STRUCTURE', 'LOCAL', 'PARAMETER',
        'TYPE', 'BINDING', 'FILE', 'NAMESPACE'
    ]
    
    EXPECTED_EDGE_TYPES = [
        'AST', 'CFG', 'REF', 'CALL', 'ARGUMENT', 'RECEIVER',
        'EVAL_TYPE', 'INHERITS_FROM', 'BINDS', 'CONTAINS'
    ]
    
    def __init__(self, cpg_file: Path):
        """Initialize parser with CPG file"""
        self.cpg_file = Path(cpg_file)
        self.data = None
        self.vertices = []
        self.edges = []
        self._parsed = False
    
    def parse(self) -> bool:
        """Parse GraphSON file and validate format"""
        try:
            with open(self.cpg_file, 'r', encoding='utf-8') as f:
                self.data = json.load(f)
            
            # Validate GraphSON v3 format
            if not self._validate_format():
                return False
                
            # Extract vertices and edges
            self.vertices = self.data['@value']['vertices']
            self.edges = self.data['@value']['edges']
            self._parsed = True
            
            return True
            
        except (FileNotFoundError, json.JSONDecodeError, KeyError) as e:
            print(f"❌ Error parsing {self.cpg_file}: {e}")
            return False
    
    def _validate_format(self) -> bool:
        """Validate GraphSON v3 TinkerPop format"""
        required_structure = [
            self.data.get('@type') == 'tinker:graph',
            '@value' in self.data,
            'vertices' in self.data['@value'],
            'edges' in self.data['@value']
        ]
        
        return all(required_structure)
    
    def get_basic_stats(self) -> Dict[str, Any]:
        """Get basic graph statistics"""
        if not self._parsed:
            return {}
            
        return {
            'file_name': self.cpg_file.name,
            'file_size_kb': round(self.cpg_file.stat().st_size / 1024, 2),
            'vertex_count': len(self.vertices),
            'edge_count': len(self.edges),
            'graph_density': len(self.edges) / len(self.vertices) if self.vertices else 0
        }
    
    def get_vertex_types(self) -> Counter:
        """Get distribution of vertex types"""
        if not self._parsed:
            return Counter()
            
        vertex_types = Counter()
        for vertex in self.vertices:
            if 'label' in vertex:
                vertex_types[vertex['label']] += 1
        
        return vertex_types
    
    def get_edge_types(self) -> Counter:
        """Get distribution of edge types"""  
        if not self._parsed:
            return Counter()
            
        edge_types = Counter()
        for edge in self.edges:
            if 'label' in edge:
                edge_types[edge['label']] += 1
                
        return edge_types
    
    def get_relationships(self) -> List[str]:
        """Get edge relationship patterns"""
        if not self._parsed:
            return []
            
        relationships = []
        for edge in self.edges:
            if 'label' in edge:
                in_label = edge.get('inVLabel', 'Unknown')
                out_label = edge.get('outVLabel', 'Unknown')
                edge_label = edge['label']
                relationship = f"{out_label} --{edge_label}--> {in_label}"
                relationships.append(relationship)
                
        return relationships
    
    def validate_cpg_types(self) -> Dict[str, Any]:
        """Validate against expected Joern CPG types"""
        if not self._parsed:
            return {}
            
        found_vertices = set(self.get_vertex_types().keys())
        found_edges = set(self.get_edge_types().keys())
        
        expected_vertices = set(self.EXPECTED_VERTEX_TYPES)
        expected_edges = set(self.EXPECTED_EDGE_TYPES)
        
        return {
            'vertex_validation': {
                'expected_found': len(found_vertices & expected_vertices),
                'total_expected': len(expected_vertices),
                'additional_types': list(found_vertices - expected_vertices),
                'missing_types': list(expected_vertices - found_vertices)
            },
            'edge_validation': {
                'expected_found': len(found_edges & expected_edges),
                'total_expected': len(expected_edges),
                'additional_types': list(found_edges - expected_edges),
                'missing_types': list(expected_edges - found_edges)
            }
        }
    
    def extract_vertex_properties(self, vertex: Dict) -> Dict[str, Any]:
        """Extract properties from a vertex with GraphSON v3 structure"""
        properties = {}
        
        if 'properties' not in vertex:
            return properties
            
        for prop_name, prop_data in vertex['properties'].items():
            if isinstance(prop_data, dict) and '@value' in prop_data:
                value_data = prop_data['@value']
                if isinstance(value_data, dict) and '@value' in value_data:
                    # GraphSON v3 structure: properties.NAME.@value.@value = [value]
                    values = value_data['@value']
                    if isinstance(values, list) and values:
                        properties[prop_name] = values[0]
                    else:
                        properties[prop_name] = values
                        
        return properties
    
    def get_analysis_summary(self) -> Dict[str, Any]:
        """Get complete analysis summary"""
        if not self._parsed:
            return {'error': 'File not parsed successfully'}
            
        return {
            'basic_stats': self.get_basic_stats(),
            'vertex_types': dict(self.get_vertex_types()),
            'edge_types': dict(self.get_edge_types()),
            'validation': self.validate_cpg_types(),
            'sample_relationships': self.get_relationships()[:10]
        }


def analyze_cpg_file(cpg_file: Path) -> Dict[str, Any]:
    """Convenience function to analyze a single CPG file"""
    parser = GraphSONParser(cpg_file)
    
    if parser.parse():
        return parser.get_analysis_summary()
    else:
        return {'error': f'Failed to parse {cpg_file}'}


if __name__ == "__main__":
    # Test the parser
    from pathlib import Path
    
    PROJECT_ROOT = Path(__file__).parent.parent.parent
    CPG_DIR = PROJECT_ROOT / 'data' / 'tmp' / 'cpg_json'
    
    # Find a sample file
    sample_files = list(CPG_DIR.rglob("*vuln_cpg.json"))
    
    if sample_files:
        result = analyze_cpg_file(sample_files[0])
        print("📊 GraphSON Parser Test Results:")
        print(json.dumps(result, indent=2))
    else:
        print("No CPG files found for testing")