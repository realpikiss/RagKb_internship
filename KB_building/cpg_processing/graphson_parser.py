"""
GraphSON v3 TinkerPop Parser for Joern CPG

This module provides utilities for parsing and validating GraphSON v3 format
generated by Joern for Code Property Graphs (CPG).
"""

import json
from pathlib import Path
from collections import Counter
from typing import Dict, List, Tuple, Optional, Any


class GraphSONParser:
    """Parser for GraphSON v3 TinkerPop format (Joern CPG)"""

    # Expected Joern CPG types
    EXPECTED_VERTEX_TYPES = [
        'METHOD', 'CALL', 'IDENTIFIER', 'LITERAL', 'RETURN',
        'BLOCK', 'CONTROL_STRUCTURE', 'LOCAL', 'PARAMETER',
        'TYPE', 'BINDING', 'FILE', 'NAMESPACE'
    ]

    EXPECTED_EDGE_TYPES = [
        'AST', 'CFG', 'REF', 'CALL', 'ARGUMENT', 'RECEIVER',
        'EVAL_TYPE', 'INHERITS_FROM', 'BINDS', 'CONTAINS'
    ]

    def __init__(self, cpg_file):
        """Initialize parser with CPG source which can be a Path/str or a dict"""
        # Accept Path/str for on-disk files, or dict for in-memory JSON
        self.cpg_file = cpg_file
        self.data = None
        self.vertices = []
        self.edges = []
        self._parsed = False
        # Optional recovered snippet of code from UNKNOWN nodes
        self.source_code: Optional[str] = None
    
    def parse(self) -> bool:
        """Parse GraphSON input and validate format"""
        try:
            # Load data from file path or in-memory dict
            if isinstance(self.cpg_file, (str, Path)):
                with open(self.cpg_file, 'r', encoding='utf-8') as f:
                    self.data = json.load(f)
            elif isinstance(self.cpg_file, dict):
                self.data = self.cpg_file
            else:
                raise TypeError("cpg_file must be a Path/str or a dict")

            # Validate GraphSON v3 format
            if not self._validate_format():
                return False

            # Extract vertices and edges
            self.vertices = self.data['@value']['vertices']
            self.edges = self.data['@value']['edges']

            # Optionally recover raw source code if embedded in UNKNOWN node
            self.source_code = None
            for v in self.vertices:
                if v.get('label') == 'UNKNOWN':
                    props = self.extract_vertex_properties(v)
                    code_val = props.get('CODE')
                    if isinstance(code_val, str) and code_val.strip():
                        self.source_code = code_val
                        break

            self._parsed = True
            return True

        except (FileNotFoundError, json.JSONDecodeError, KeyError, TypeError) as e:
            print(f"❌ Error parsing CPG: {e}")
            return False
    
    def _validate_format(self) -> bool:
        """Validate GraphSON v3 TinkerPop format"""
        required_structure = [
            self.data.get('@type') == 'tinker:graph',
            '@value' in self.data,
            'vertices' in self.data['@value'],
            'edges' in self.data['@value']
        ]
        
        return all(required_structure)
    
    def get_basic_stats(self) -> Dict[str, Any]:
        """Get basic graph statistics"""
        if not self._parsed:
            return {}

        file_name = None
        file_size_kb = 0.0
        try:
            if isinstance(self.cpg_file, Path):
                file_name = self.cpg_file.name
                file_size_kb = round(self.cpg_file.stat().st_size / 1024, 2)
            elif isinstance(self.cpg_file, str):
                p = Path(self.cpg_file)
                file_name = p.name
                file_size_kb = round(p.stat().st_size / 1024, 2) if p.exists() else 0.0
            else:
                file_name = 'in_memory.json'
        except Exception:
            file_name = file_name or 'unknown'
            file_size_kb = 0.0

        return {
            'file_name': file_name,
            'file_size_kb': file_size_kb,
            'vertex_count': len(self.vertices),
            'edge_count': len(self.edges),
            'graph_density': len(self.edges) / len(self.vertices) if self.vertices else 0
        }
    
    def get_vertex_types(self) -> Counter:
        """Get distribution of vertex types"""
        if not self._parsed:
            return Counter()
            
        vertex_types = Counter()
        for vertex in self.vertices:
            if 'label' in vertex:
                vertex_types[vertex['label']] += 1
        
        return vertex_types
    
    def get_edge_types(self) -> Counter:
        """Get distribution of edge types"""  
        if not self._parsed:
            return Counter()
            
        edge_types = Counter()
        for edge in self.edges:
            if 'label' in edge:
                edge_types[edge['label']] += 1
                
        return edge_types
    
    def get_relationships(self) -> List[str]:
        """Get edge relationship patterns"""
        if not self._parsed:
            return []
            
        relationships = []
        for edge in self.edges:
            if 'label' in edge:
                in_label = edge.get('inVLabel', 'Unknown')
                out_label = edge.get('outVLabel', 'Unknown')
                edge_label = edge['label']
                relationship = f"{out_label} --{edge_label}--> {in_label}"
                relationships.append(relationship)
                
        return relationships
    
    def validate_cpg_types(self) -> Dict[str, Any]:
        """Validate against expected Joern CPG types"""
        if not self._parsed:
            return {}
            
        found_vertices = set(self.get_vertex_types().keys())
        found_edges = set(self.get_edge_types().keys())
        
        expected_vertices = set(self.EXPECTED_VERTEX_TYPES)
        expected_edges = set(self.EXPECTED_EDGE_TYPES)
        
        return {
            'vertex_validation': {
                'expected_found': len(found_vertices & expected_vertices),
                'total_expected': len(expected_vertices),
                'additional_types': list(found_vertices - expected_vertices),
                'missing_types': list(expected_vertices - found_vertices)
            },
            'edge_validation': {
                'expected_found': len(found_edges & expected_edges),
                'total_expected': len(expected_edges),
                'additional_types': list(found_edges - expected_edges),
                'missing_types': list(expected_edges - found_edges)
            }
        }
    
    def extract_vertex_properties(self, vertex: Dict) -> Dict[str, Any]:
        """Extract properties from a vertex with GraphSON v3 structure (robust)"""
        props_out: Dict[str, Any] = {}
        props_in = vertex.get('properties', {}) or {}

        for name, pdata in props_in.items():
            val = None
            try:
                # Typical GraphSON v3 encoding nests values under @value twice
                v1 = pdata.get('@value') if isinstance(pdata, dict) else None
                if isinstance(v1, dict) and '@value' in v1:
                    vv = v1['@value']
                    if isinstance(vv, list):
                        val = vv[0] if vv else None
                    else:
                        val = vv
                elif v1 is not None:
                    val = v1
                else:
                    # Fallback: accept raw data
                    val = pdata
            except Exception:
                val = None

            if val is not None:
                props_out[name] = val

        return props_out
    
    def get_analysis_summary(self) -> Dict[str, Any]:
        """Get complete analysis summary"""
        if not self._parsed:
            return {'error': 'File not parsed successfully'}
            
        return {
            'basic_stats': self.get_basic_stats(),
            'vertex_types': dict(self.get_vertex_types()),
            'edge_types': dict(self.get_edge_types()),
            'validation': self.validate_cpg_types(),
            'sample_relationships': self.get_relationships()[:10]
        }


def analyze_cpg_file(cpg_file: Path) -> Dict[str, Any]:
    """Convenience function to analyze a single CPG file"""
    parser = GraphSONParser(cpg_file)
    
    if parser.parse():
        return parser.get_analysis_summary()
    else:
        return {'error': f'Failed to parse {cpg_file}'}


if __name__ == "__main__":
    # Test the parser
    from pathlib import Path
    
    PROJECT_ROOT = Path(__file__).parent.parent.parent
    CPG_DIR = PROJECT_ROOT / 'data' / 'tmp' / 'cpg_json'
    
    # Find a sample file
    sample_files = list(CPG_DIR.rglob("*vuln_cpg.json"))
    
    if sample_files:
        result = analyze_cpg_file(sample_files[0])
        print("📊 GraphSON Parser Test Results:")
        print(json.dumps(result, indent=2))
    else:
        print("No CPG files found for testing")